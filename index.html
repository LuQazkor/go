<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>ICU Third Person</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no"/>

<style>
html, body {
  width: 100%;
  height: 100%;
  margin: 0;
  overflow: hidden;
  touch-action: none;
  background: #000;
}
#renderCanvas {
  width: 100%;
  height: 100%;
  display: block;
}
</style>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>

<body>
<canvas id="renderCanvas"></canvas>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

const createScene = async () => {
  const scene = new BABYLON.Scene(engine);
  scene.clearColor = new BABYLON.Color3(0,0,0);

  scene.collisionsEnabled = true;
  scene.gravity = new BABYLON.Vector3(0, -0.3, 0);

  // Light
  const light = new BABYLON.HemisphericLight(
    "light",
    new BABYLON.Vector3(0, 1, 0),
    scene
  );
  light.intensity = 0.9;

  // Load ICU room
  const roomResult = await BABYLON.SceneLoader.ImportMeshAsync(
    "",
    "./glb/",
    "ICU.glb",
    scene
  );

  roomResult.meshes.forEach(m => {
    m.checkCollisions = true;
  });

  // Load avatar
  const avatarResult = await BABYLON.SceneLoader.ImportMeshAsync(
    "",
    "./glb/",
    "avatar.glb",   // ðŸ‘ˆ CHANGE NAME IF NEEDED
    scene
  );

  const avatarRoot = new BABYLON.TransformNode("avatarRoot", scene);
  avatarResult.meshes.forEach(m => {
    if (m !== avatarResult.meshes[0]) {
      m.parent = avatarRoot;
    }
  });

  // Normalize avatar scale
  const bounds = avatarRoot.getHierarchyBoundingVectors();
  const height = bounds.max.y - bounds.min.y;
  const scale = 1.7 / height; // human height
  avatarRoot.scaling.setAll(scale);

  // Start position
  avatarRoot.position = new BABYLON.Vector3(0, 0, 0);
  avatarRoot.checkCollisions = true;

  // Invisible collision body (NO white capsule)
  const collider = BABYLON.MeshBuilder.CreateCapsule("collider", {
    height: 1.7,
    radius: 0.35
  }, scene);
  collider.isVisible = false;
  collider.position.y = 0.85;
  collider.checkCollisions = true;
  collider.applyGravity = true;

  avatarRoot.parent = collider;

  // THIRD PERSON CAMERA (Babylon native)
  const camera = new BABYLON.ArcRotateCamera(
    "camera",
    Math.PI,
    Math.PI / 3,
    3.5,
    collider.position,
    scene
  );

  camera.attachControl(canvas, true);
  camera.lowerRadiusLimit = 2;
  camera.upperRadiusLimit = 6;
  camera.wheelPrecision = 100;
  camera.panningSensibility = 0;
  camera.angularSensibilityX = 4000;
  camera.angularSensibilityY = 4000;

  // Mobile joystick movement (Babylon)
  camera.inputs.removeByType("ArcRotateCameraKeyboardMoveInput");
  camera.inputs.addVirtualJoystick();

  scene.onBeforeRenderObservable.add(() => {
    const fwd = camera.getDirection(BABYLON.Axis.Z);
    fwd.y = 0;
    fwd.normalize();

    const speed = 0.06;
    if (camera.inputs.attached.virtualJoystick?.pressed) {
      collider.moveWithCollisions(fwd.scale(speed));
      avatarRoot.rotation.y = Math.atan2(fwd.x, fwd.z);
    }
  });

  return scene;
};

createScene().then(scene => {
  engine.runRenderLoop(() => {
    scene.render();
  });
});

window.addEventListener("resize", () => {
  engine.resize();
});
</script>
</body>
</html>
